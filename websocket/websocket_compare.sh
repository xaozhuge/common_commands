# 1. 短轮询(short polling)
# 实现方式: 浏览器 定时(如每秒)向服务器发送 HTTP 请求, 服务器立即返回当前数据(无论是否有更新)
# 优点: 实现简单, 兼容性极佳
# 缺点: 高频请求浪费资源, 实时性差(依赖轮询间隔)
# 延迟: 高(取决于轮询频率)
# 适用场景: 兼容性要求高, 延迟不敏感的简单场景

# 2. 长轮询(long polling)
# 实现方式: 浏览器发送HTTP请求后, 服务器 挂起连接 直到数据更新或超时, 返回响应后浏览器立即发起新请求
# 优点: 减少无效请求, 比短轮询实时性更好
# 缺点: 服务器需维护挂起连接, 高并发时资源消耗大
# 延迟: 中(取决于数据更新频率)
# 适用场景: 需要较好实时性且无法用 WebSocket/SSE 的场景(如消息通知)
# 案例: 客户端发起请求后, Nacos 服务端不会立即返回请求结果, 而是将请求挂起一段时间, 如果此段时间内服务端数据变更,
# 立即响应客户端请求, 若是一直无变化则等到指定的超时时间后响应请求, 客户端重新发起长轮询

# 3. WebSocket
# 实现方式: 基于 TCP 的全双工协议, 通过 HTTP 升级握手(Upgade: websocket)建立持久连接(双向实时通信)
# 优点: 最低延迟, 支持双向交互, 节省带宽
# 缺点: 实现复杂, 需单独处理连接状态
# 延迟: 极低
# 适用场景: 聊天室、在线游戏、协同编辑等 高实时双向交互 需求

# 4. Server Send Event(SSE)
# 实现方式: 基于 HTTP 协议, 服务器可 主动推送 数据流(如 Content-Type: text/event-stream), 浏览器通过 EventSource API监听
# 优点: 原生支持断线重连, 轻量级(HTTP协议)
# 缺点: 单向通信(服务端-->客户端), 低版本IE浏览器不支持
# 延迟: 低(服务器可及时推送)

